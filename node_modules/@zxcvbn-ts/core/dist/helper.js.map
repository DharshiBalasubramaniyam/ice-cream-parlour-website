{"version":3,"file":"helper.js","sources":["../src/helper.ts"],"sourcesContent":["export const empty = (obj) => Object.keys(obj).length === 0;\nexport const extend = (listToExtend, list) => \n// eslint-disable-next-line prefer-spread\nlistToExtend.push.apply(listToExtend, list);\nexport const translate = (string, chrMap) => {\n    let newString = string;\n    Object.entries(chrMap).forEach(([key, value]) => {\n        const escapedKey = key.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n        const regex = new RegExp(escapedKey, 'g');\n        newString = newString.replace(regex, value);\n    });\n    return newString;\n};\n// mod implementation that works for negative numbers\nexport const mod = (n, m) => ((n % m) + m) % m;\n// sort on i primary, j secondary\nexport const sorted = (matches) => matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j);\nexport const buildRankedDictionary = (orderedList) => {\n    const result = {};\n    let counter = 1; // rank starts at 1, not 0\n    orderedList.forEach((word) => {\n        result[word] = counter;\n        counter += 1;\n    });\n    return result;\n};\n//# sourceMappingURL=helper.js.map"],"names":["extend","listToExtend","list","push","apply","sorted","matches","sort","m1","m2","i","j","buildRankedDictionary","orderedList","result","counter","forEach","word"],"mappings":";;MACaA,MAAM,GAAGA,CAACC,YAAY,EAAEC,IAAI;AACzC;AACAD,YAAY,CAACE,IAAI,CAACC,KAAK,CAACH,YAAY,EAAEC,IAAI,EAAC;AAY3C;AACaG,MAAAA,MAAM,GAAIC,OAAO,IAAKA,OAAO,CAACC,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKD,EAAE,CAACE,CAAC,GAAGD,EAAE,CAACC,CAAC,IAAIF,EAAE,CAACG,CAAC,GAAGF,EAAE,CAACE,CAAC,EAAC;AAC1EC,MAAAA,qBAAqB,GAAIC,WAAW,IAAK;EAClD,MAAMC,MAAM,GAAG,EAAE,CAAA;AACjB,EAAA,IAAIC,OAAO,GAAG,CAAC,CAAC;AAChBF,EAAAA,WAAW,CAACG,OAAO,CAAEC,IAAI,IAAK;AAC1BH,IAAAA,MAAM,CAACG,IAAI,CAAC,GAAGF,OAAO,CAAA;AACtBA,IAAAA,OAAO,IAAI,CAAC,CAAA;AAChB,GAAC,CAAC,CAAA;AACF,EAAA,OAAOD,MAAM,CAAA;AACjB;;;;;;"}