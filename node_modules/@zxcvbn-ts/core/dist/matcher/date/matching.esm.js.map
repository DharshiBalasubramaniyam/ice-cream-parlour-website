{"version":3,"file":"matching.esm.js","sources":["../../../src/matcher/date/matching.ts"],"sourcesContent":["import { DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, REFERENCE_YEAR, } from '../../data/const';\nimport { sorted } from '../../helper';\n/*\n * -------------------------------------------------------------------------------\n *  date matching ----------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchDate {\n    /*\n     * a \"date\" is recognized as:\n     *   any 3-tuple that starts or ends with a 2- or 4-digit year,\n     *   with 2 or 0 separator chars (1.1.91 or 1191),\n     *   maybe zero-padded (01-01-91 vs 1-1-91),\n     *   a month between 1 and 12,\n     *   a day between 1 and 31.\n     *\n     * note: this isn't true date parsing in that \"feb 31st\" is allowed,\n     * this doesn't check for leap years, etc.\n     *\n     * recipe:\n     * start with regex to find maybe-dates, then attempt to map the integers\n     * onto month-day-year to filter the maybe-dates into dates.\n     * finally, remove matches that are substrings of other matches to reduce noise.\n     *\n     * note: instead of using a lazy or greedy regex to find many dates over the full string,\n     * this uses a ^...$ regex against every substring of the password -- less performant but leads\n     * to every possible date match.\n     */\n    match({ password }) {\n        const matches = [\n            ...this.getMatchesWithoutSeparator(password),\n            ...this.getMatchesWithSeparator(password),\n        ];\n        const filteredMatches = this.filterNoise(matches);\n        return sorted(filteredMatches);\n    }\n    getMatchesWithSeparator(password) {\n        const matches = [];\n        const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n        // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n        for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n            for (let j = i + 5; j <= i + 9; j += 1) {\n                if (j >= password.length) {\n                    break;\n                }\n                const token = password.slice(i, +j + 1 || 9e9);\n                const regexMatch = maybeDateWithSeparator.exec(token);\n                if (regexMatch != null) {\n                    const dmy = this.mapIntegersToDayMonthYear([\n                        parseInt(regexMatch[1], 10),\n                        parseInt(regexMatch[3], 10),\n                        parseInt(regexMatch[4], 10),\n                    ]);\n                    if (dmy != null) {\n                        matches.push({\n                            pattern: 'date',\n                            token,\n                            i,\n                            j,\n                            separator: regexMatch[2],\n                            year: dmy.year,\n                            month: dmy.month,\n                            day: dmy.day,\n                        });\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    // eslint-disable-next-line max-statements\n    getMatchesWithoutSeparator(password) {\n        const matches = [];\n        const maybeDateNoSeparator = /^\\d{4,8}$/;\n        const metric = (candidate) => Math.abs(candidate.year - REFERENCE_YEAR);\n        // # dates without separators are between length 4 '1191' and 8 '11111991'\n        for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n            for (let j = i + 3; j <= i + 7; j += 1) {\n                if (j >= password.length) {\n                    break;\n                }\n                const token = password.slice(i, +j + 1 || 9e9);\n                if (maybeDateNoSeparator.exec(token)) {\n                    const candidates = [];\n                    const index = token.length;\n                    const splittedDates = DATE_SPLITS[index];\n                    splittedDates.forEach(([k, l]) => {\n                        const dmy = this.mapIntegersToDayMonthYear([\n                            parseInt(token.slice(0, k), 10),\n                            parseInt(token.slice(k, l), 10),\n                            parseInt(token.slice(l), 10),\n                        ]);\n                        if (dmy != null) {\n                            candidates.push(dmy);\n                        }\n                    });\n                    if (candidates.length > 0) {\n                        /*\n                         * at this point: different possible dmy mappings for the same i,j substring.\n                         * match the candidate date that likely takes the fewest guesses: a year closest\n                         * to 2000.\n                         * (scoring.REFERENCE_YEAR).\n                         *\n                         * ie, considering '111504', prefer 11-15-04 to 1-1-1504\n                         * (interpreting '04' as 2004)\n                         */\n                        let bestCandidate = candidates[0];\n                        let minDistance = metric(candidates[0]);\n                        candidates.slice(1).forEach((candidate) => {\n                            const distance = metric(candidate);\n                            if (distance < minDistance) {\n                                bestCandidate = candidate;\n                                minDistance = distance;\n                            }\n                        });\n                        matches.push({\n                            pattern: 'date',\n                            token,\n                            i,\n                            j,\n                            separator: '',\n                            year: bestCandidate.year,\n                            month: bestCandidate.month,\n                            day: bestCandidate.day,\n                        });\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    /*\n     * matches now contains all valid date strings in a way that is tricky to capture\n     * with regexes only. while thorough, it will contain some unintuitive noise:\n     *\n     * '2015_06_04', in addition to matching 2015_06_04, will also contain\n     * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n     *\n     * to reduce noise, remove date matches that are strict substrings of others\n     */\n    filterNoise(matches) {\n        return matches.filter((match) => {\n            let isSubmatch = false;\n            const matchesLength = matches.length;\n            for (let o = 0; o < matchesLength; o += 1) {\n                const otherMatch = matches[o];\n                if (match !== otherMatch) {\n                    if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n                        isSubmatch = true;\n                        break;\n                    }\n                }\n            }\n            return !isSubmatch;\n        });\n    }\n    /*\n     * given a 3-tuple, discard if:\n     *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n     *   middle int is zero\n     *   any int is over the max allowable year\n     *   any int is over two digits but under the min allowable year\n     *   2 integers are over 31, the max allowable day\n     *   2 integers are zero\n     *   all integers are over 12, the max allowable month\n     */\n    // eslint-disable-next-line complexity, max-statements\n    mapIntegersToDayMonthYear(integers) {\n        if (integers[1] > 31 || integers[1] <= 0) {\n            return null;\n        }\n        let over12 = 0;\n        let over31 = 0;\n        let under1 = 0;\n        for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n            const int = integers[o];\n            if ((int > 99 && int < DATE_MIN_YEAR) || int > DATE_MAX_YEAR) {\n                return null;\n            }\n            if (int > 31) {\n                over31 += 1;\n            }\n            if (int > 12) {\n                over12 += 1;\n            }\n            if (int <= 0) {\n                under1 += 1;\n            }\n        }\n        if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n            return null;\n        }\n        return this.getDayMonth(integers);\n    }\n    // eslint-disable-next-line max-statements\n    getDayMonth(integers) {\n        // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n        const possibleYearSplits = [\n            [integers[2], integers.slice(0, 2)],\n            [integers[0], integers.slice(1, 3)], // year first\n        ];\n        const possibleYearSplitsLength = possibleYearSplits.length;\n        for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n            const [y, rest] = possibleYearSplits[j];\n            if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n                const dm = this.mapIntegersToDayMonth(rest);\n                if (dm != null) {\n                    return {\n                        year: y,\n                        month: dm.month,\n                        day: dm.day,\n                    };\n                }\n                /*\n                 * for a candidate that includes a four-digit year,\n                 * when the remaining integers don't match to a day and month,\n                 * it is not a date.\n                 */\n                return null;\n            }\n        }\n        // given no four-digit year, two digit years are the most flexible int to match, so\n        // try to parse a day-month out of integers[0..1] or integers[1..0]\n        for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n            const [y, rest] = possibleYearSplits[k];\n            const dm = this.mapIntegersToDayMonth(rest);\n            if (dm != null) {\n                return {\n                    year: this.twoToFourDigitYear(y),\n                    month: dm.month,\n                    day: dm.day,\n                };\n            }\n        }\n        return null;\n    }\n    mapIntegersToDayMonth(integers) {\n        const temp = [integers, integers.slice().reverse()];\n        for (let i = 0; i < temp.length; i += 1) {\n            const data = temp[i];\n            const day = data[0];\n            const month = data[1];\n            if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n                return {\n                    day,\n                    month,\n                };\n            }\n        }\n        return null;\n    }\n    twoToFourDigitYear(year) {\n        if (year > 99) {\n            return year;\n        }\n        if (year > 50) {\n            // 87 -> 1987\n            return year + 1900;\n        }\n        // 15 -> 2015\n        return year + 2000;\n    }\n}\nexport default MatchDate;\n//# sourceMappingURL=matching.js.map"],"names":["MatchDate","match","password","matches","getMatchesWithoutSeparator","getMatchesWithSeparator","filteredMatches","filterNoise","sorted","maybeDateWithSeparator","i","Math","abs","length","j","token","slice","regexMatch","exec","dmy","mapIntegersToDayMonthYear","parseInt","push","pattern","separator","year","month","day","maybeDateNoSeparator","metric","candidate","REFERENCE_YEAR","candidates","index","splittedDates","DATE_SPLITS","forEach","k","l","bestCandidate","minDistance","distance","filter","isSubmatch","matchesLength","o","otherMatch","integers","over12","over31","under1","len1","int","DATE_MIN_YEAR","DATE_MAX_YEAR","getDayMonth","possibleYearSplits","possibleYearSplitsLength","y","rest","dm","mapIntegersToDayMonth","twoToFourDigitYear","temp","reverse","data"],"mappings":"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"}