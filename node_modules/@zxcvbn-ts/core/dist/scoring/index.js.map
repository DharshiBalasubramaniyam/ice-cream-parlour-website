{"version":3,"file":"index.js","sources":["../../src/scoring/index.ts"],"sourcesContent":["import utils from './utils';\nimport estimateGuesses from './estimate';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const';\nconst scoringHelper = {\n    password: '',\n    optimal: {},\n    excludeAdditive: false,\n    separatorRegex: undefined,\n    fillArray(size, valueType) {\n        const result = [];\n        for (let i = 0; i < size; i += 1) {\n            let value = [];\n            if (valueType === 'object') {\n                value = {};\n            }\n            result.push(value);\n        }\n        return result;\n    },\n    // helper: make bruteforce match objects spanning i to j, inclusive.\n    makeBruteforceMatch(i, j) {\n        return {\n            pattern: 'bruteforce',\n            token: this.password.slice(i, +j + 1 || 9e9),\n            i,\n            j,\n        };\n    },\n    // helper: considers whether a length-sequenceLength\n    // sequence ending at match m is better (fewer guesses)\n    // than previously encountered sequences, updating state if so.\n    update(match, sequenceLength) {\n        const k = match.j;\n        const estimatedMatch = estimateGuesses(match, this.password);\n        let pi = estimatedMatch.guesses;\n        if (sequenceLength > 1) {\n            // we're considering a length-sequenceLength sequence ending with match m:\n            // obtain the product term in the minimization function by multiplying m's guesses\n            // by the product of the length-(sequenceLength-1)\n            // sequence ending just before m, at m.i - 1.\n            pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n        }\n        // calculate the minimization func\n        let g = utils.factorial(sequenceLength) * pi;\n        if (!this.excludeAdditive) {\n            g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n        }\n        // update state if new best.\n        // first see if any competing sequences covering this prefix,\n        // with sequenceLength or fewer matches,\n        // fare better than this sequence. if so, skip it and return.\n        let shouldSkip = false;\n        Object.keys(this.optimal.g[k]).forEach((competingPatternLength) => {\n            const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n            if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n                if (competingMetricMatch <= g) {\n                    shouldSkip = true;\n                }\n            }\n        });\n        if (!shouldSkip) {\n            // this sequence might be part of the final optimal sequence.\n            this.optimal.g[k][sequenceLength] = g;\n            this.optimal.m[k][sequenceLength] = estimatedMatch;\n            this.optimal.pi[k][sequenceLength] = pi;\n        }\n    },\n    // helper: evaluate bruteforce matches ending at passwordCharIndex.\n    bruteforceUpdate(passwordCharIndex) {\n        // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n        let match = this.makeBruteforceMatch(0, passwordCharIndex);\n        this.update(match, 1);\n        for (let i = 1; i <= passwordCharIndex; i += 1) {\n            // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n            // see if adding these new matches to any of the sequences in optimal[i-1]\n            // leads to new bests.\n            match = this.makeBruteforceMatch(i, passwordCharIndex);\n            const tmp = this.optimal.m[i - 1];\n            // eslint-disable-next-line no-loop-func\n            Object.keys(tmp).forEach((sequenceLength) => {\n                const lastMatch = tmp[sequenceLength];\n                // corner: an optimal sequence will never have two adjacent bruteforce matches.\n                // it is strictly better to have a single bruteforce match spanning the same region:\n                // same contribution to the guess product with a lower length.\n                // --> safe to skip those cases.\n                if (lastMatch.pattern !== 'bruteforce') {\n                    // try adding m to this length-sequenceLength sequence.\n                    this.update(match, parseInt(sequenceLength, 10) + 1);\n                }\n            });\n        }\n    },\n    // helper: step backwards through optimal.m starting at the end,\n    // constructing the final optimal match sequence.\n    unwind(passwordLength) {\n        const optimalMatchSequence = [];\n        let k = passwordLength - 1;\n        // find the final best sequence length and score\n        let sequenceLength = 0;\n        // eslint-disable-next-line no-loss-of-precision\n        let g = 2e308;\n        const temp = this.optimal.g[k];\n        // safety check for empty passwords\n        if (temp) {\n            Object.keys(temp).forEach((candidateSequenceLength) => {\n                const candidateMetricMatch = temp[candidateSequenceLength];\n                if (candidateMetricMatch < g) {\n                    sequenceLength = parseInt(candidateSequenceLength, 10);\n                    g = candidateMetricMatch;\n                }\n            });\n        }\n        while (k >= 0) {\n            const match = this.optimal.m[k][sequenceLength];\n            optimalMatchSequence.unshift(match);\n            k = match.i - 1;\n            sequenceLength -= 1;\n        }\n        return optimalMatchSequence;\n    },\n};\nexport default {\n    // ------------------------------------------------------------------------------\n    // search --- most guessable match sequence -------------------------------------\n    // ------------------------------------------------------------------------------\n    //\n    // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n    // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n    // for a length-n password with m candidate matches. l_max is the maximum optimal\n    // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n    // search terminates rapidly.\n    //\n    // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n    // minimizes the following function:\n    //\n    //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n    //\n    // where sequenceLength is the length of the sequence.\n    //\n    // the factorial term is the number of ways to order sequenceLength patterns.\n    //\n    // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n    // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n    //\n    // for example, consider a sequence that is date-repeat-dictionary.\n    //  - an attacker would need to try other date-repeat-dictionary combinations,\n    //    hence the product term.\n    //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n    //    ..., hence the factorial term.\n    //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n    //    sequences before length-3. assuming at minimum D guesses per pattern type,\n    //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n    //\n    // ------------------------------------------------------------------------------\n    mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n        scoringHelper.password = password;\n        scoringHelper.excludeAdditive = excludeAdditive;\n        const passwordLength = password.length;\n        // partition matches into sublists according to ending index j\n        let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n        matches.forEach((match) => {\n            matchesByCoordinateJ[match.j].push(match);\n        });\n        // small detail: for deterministic output, sort each sublist by i.\n        matchesByCoordinateJ = matchesByCoordinateJ.map((match) => match.sort((m1, m2) => m1.i - m2.i));\n        scoringHelper.optimal = {\n            // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n            // match sequence covering the\n            // password prefix up to k, inclusive.\n            // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n            // a shorter match sequence spanning the same prefix,\n            // optimal.m[k][sequenceLength] is undefined.\n            m: scoringHelper.fillArray(passwordLength, 'object'),\n            // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n            // optimal.pi allows for fast (non-looping) updates to the minimization function.\n            pi: scoringHelper.fillArray(passwordLength, 'object'),\n            // same structure as optimal.m -- holds the overall metric.\n            g: scoringHelper.fillArray(passwordLength, 'object'),\n        };\n        for (let k = 0; k < passwordLength; k += 1) {\n            matchesByCoordinateJ[k].forEach((match) => {\n                if (match.i > 0) {\n                    Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach((sequenceLength) => {\n                        scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n                    });\n                }\n                else {\n                    scoringHelper.update(match, 1);\n                }\n            });\n            scoringHelper.bruteforceUpdate(k);\n        }\n        const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n        const optimalSequenceLength = optimalMatchSequence.length;\n        const guesses = this.getGuesses(password, optimalSequenceLength);\n        return {\n            password,\n            guesses,\n            guessesLog10: utils.log10(guesses),\n            sequence: optimalMatchSequence,\n        };\n    },\n    getGuesses(password, optimalSequenceLength) {\n        const passwordLength = password.length;\n        let guesses = 0;\n        if (password.length === 0) {\n            guesses = 1;\n        }\n        else {\n            guesses =\n                scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n        }\n        return guesses;\n    },\n};\n//# sourceMappingURL=index.js.map"],"names":["scoringHelper","password","optimal","excludeAdditive","separatorRegex","undefined","fillArray","size","valueType","result","i","value","push","makeBruteforceMatch","j","pattern","token","slice","update","match","sequenceLength","k","estimatedMatch","estimateGuesses","pi","guesses","g","utils","factorial","MIN_GUESSES_BEFORE_GROWING_SEQUENCE","shouldSkip","Object","keys","forEach","competingPatternLength","competingMetricMatch","parseInt","m","bruteforceUpdate","passwordCharIndex","tmp","lastMatch","unwind","passwordLength","optimalMatchSequence","temp","candidateSequenceLength","candidateMetricMatch","unshift","mostGuessableMatchSequence","matches","length","matchesByCoordinateJ","map","sort","m1","m2","optimalSequenceLength","getGuesses","guessesLog10","log10","sequence"],"mappings":"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"}